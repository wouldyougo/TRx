using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using TRL.Common.Models;
using TRL.Common.Data;
using TRL.Common.Extensions.Data;
using System.Collections.Specialized;
using TRL.Common.TimeHelpers;
using TRL.Common.Collections;
using TRL.Logging;

namespace TRL.Common.Handlers
{
    // <summary>
    // делаем из тиков рейндж бары:
    // первый вариант:
    // обрабатываем поступление нового тика:
    // поступивший тик добавляем в текущий бар
    //     если текущий бар отсутсвует или
    //     если текущий бар в состоянии "закончен"
    //     создаем новый текущий бар
    //         сгенерировать событие на "создание" бара
    //     добавить новый текущий бар в контекст
    //     проверяем завершение бара новым тиком
    //         если текущий бар готов т.е. может быть закончен
    //             переводим текущий бар в состояние "закончен"
    //             сгенерировать событие на "закончен" бара
    //     выходим из процесса обработки
    //
    // в этом случае интервал завершенного бара >= лимиту рейндж
    // после завершения бара новый бар не создается до поступления нового тика
    //             
    // вариант без проскальзывания:
    // обрабатываем поступление нового тика
    // ц0
    // п0 если текущий бар в состоянии "закончен"
    //         создаем новый текущий бар
    //         цена открытия = цене закрытия предыдущего бара
    //         переводим текущий бар в состоянии "обновлен"
    //         переходим в п1
    // п1 если текущий бар в состоянии "обновлен"
    //     проверяем возможность добавления нового тика в текущий бар
    //     если тело бара + расстояние до тика > значения интревала
    //     если добавить нельзя
    //         переводим текущий бар в состояние "закончен"
    //         цена закрытия = цене открытия + интервал
    //             сгенерировать событие на "закончен" бара
    //         добавить "законченый" бар в контекст
    //         переходим в п0
    //         continue;
    //     если добавить можно        
    //     если значения интревала >= тело бара + расстояние до тика
    //         поступивший тик добавляем в текущий бар
    //         если значения интревала >  тело бара + расстояние до тика
    //         сгенерировать событие бара "обновлен"
    //         если значения интревала == тело бара + расстояние до тика
    //         сгенерировать событие бара "закончен"
    //         выходим из процесса обработки
    //         break;
    // п2 если текущий бар отсутсвует
    //     создаем новый текущий бар
    //         поступивший тик добавляем в текущий бар
    //         цена открытия = цене поступивщего тика
    //         переводим текущий бар в состоянии "обновлен"
    //         выходим из процесса обработки
    //         break;
    // в этом случае лимит у рейнджа >= рейнджа завершенного бара
    // //новый бар завершается сразу после достижения интервала бара
    // новый бар завершается сразу после превышения интервала бара
    // добавить параметр проскальзывание для Range?
    // </summary>

    /// <summary>
    /// делаем из тиков рейндж бары
    /// </summary>
    public class MakeRangeBarsOnTick:AddedItemHandler<Tick>
    {
        private IDataContext tradingData;
        private BarSettings barSettings;
        private ITimeTrackable timeTracker;
        private ILogger logger;
        private BarBuilder barBuilder;
        private Bar barCurrent;       

        public MakeRangeBarsOnTick(BarSettings barSettings, ITimeTrackable timeTracker, IDataContext tradingData, ILogger logger)
            : base(tradingData.Get<ObservableCollection<Tick>>())
        {
            this.tradingData = tradingData;
            this.barSettings = barSettings;
            this.timeTracker = timeTracker;
            this.logger = logger;
            //подменяем тип бара на RangeBar
            if (this.barSettings.BarType != Enums.DataModelType.RangeBar)
                this.barSettings.BarType  = Enums.DataModelType.RangeBar;
            this.barBuilder = new BarBuilder(barSettings);
        }

        /// <summary>
        /// делаем из тиков рейндж бары:
        /// первый вариант:
        /// обрабатываем поступление нового тика:
        /// поступивший тик добавляем в текущий бар
        ///     если текущий бар отсутсвует или
        ///     если текущий бар в состоянии "закончен"
        ///     создаем новый текущий бар
        ///         сгенерировать событие на "создание" бара
        ///     добавить новый текущий бар в контекст
        ///     проверяем завершение бара новым тиком
        ///         если текущий бар готов т.е. может быть закончен
        ///             переводим текущий бар в состояние "закончен"
        ///             сгенерировать событие на "закончен" бара
        ///     выходим из процесса обработки
        ///
        /// в этом случае рейндж завершенного бара >= лимиту рейндж
        /// после завершения бара новый бар не создается до поступления нового тика
        /// 
        /// сущности 
        ///     тик
        ///     текущий бар
        /// </summary>
        /// <param name="tick"></param>
        public void OnItemAdded_v1(Tick tick)
        {
            /// обрабатываем поступление нового тика:
            /// валидация Symbol тика
            if (barSettings.Symbol != tick.Symbol)
            {
                if (tick.Symbol == "")
                {
                    tick.Symbol = barSettings.Symbol;
                }
                else
                {
                    return;
                }
            }

            /// <summary>
            /// внутренние состояния обработчика в процессе обработки тика
            /// </summary>
            String state = "Update";

            ///     если текущий бар отсутсвует или
            ///     если текущий бар в состоянии "закончен"
            if ((barCurrent == null) ||
                (barCurrent.State == Enums.BarState.Finished))
            {
                state = "Create";
                /// создаем новый текущий бар
                barCurrent = barBuilder.CreateBar(tick, tick.DateTime);
                ///         сгенерировать событие на "создание" бара
            }

            /// поступивший тик добавляем в текущий бар
            else if (state == "Update")
            {
                barCurrent = barBuilder.UpdateBar(barCurrent, tick);
                state = "Updated";
            }
            ///     проверяем завершение бара новым тиком
            if (barBuilder.CheckRangeReach(barCurrent))
            {
                ///         если текущий бар готов т.е. может быть закончен
                ///             переводим текущий бар в состояние "закончен"
                barBuilder.FinishBarState(barCurrent);
                state = "Finished";
                ///             сгенерировать событие на "закончен" бара
                ///             добавить завершенный бар в контекст                    
                this.logger.Log(String.Format("{0:dd/MM/yyyy H:mm:ss.fff}, {1}, добавлен новый бар {2}", DateTime.Now, this.GetType().Name, barCurrent.ToString()));
                this.tradingData.Get<ObservableCollection<Bar>>().Add(barCurrent);
            }
        }

        /// <summary>
        /// обрабатываем поступление нового тика
        /// ц0
        /// п0 если текущий бар в состоянии "закончен"
        ///         создаем новый текущий бар
        ///         цена открытия = цене закрытия предыдущего бара
        ///         переводим текущий бар в состоянии "обновлен"
        ///         переходим в п1
        /// п1 если текущий бар в состоянии "обновлен"
        ///     проверяем возможность добавления нового тика в текущий бар
        ///     если тело бара + расстояние до тика > значения интревала
        ///     если добавить нельзя
        ///         переводим текущий бар в состояние "закончен"
        ///         цена закрытия = цене открытия + интервал
        ///             сгенерировать событие на "закончен" бара
        ///         добавить "законченый" бар в контекст
        ///         переходим в п0
        ///         continue;
        ///     если добавить можно        
        ///     если значения интревала >= тело бара + расстояние до тика
        ///         поступивший тик добавляем в текущий бар
        ///         сгенерировать событие бара "обновлен"
        ///         выходим из процесса обработки
        ///         break;
        /// п2 если текущий бар отсутсвует
        ///     создаем новый текущий бар
        ///         поступивший тик добавляем в текущий бар
        ///         цена открытия = цене поступивщего тика
        ///         переводим текущий бар в состоянии "обновлен"
        ///         выходим из процесса обработки
        ///         break;
        /// //новый бар завершается сразу после достижения интервала бара
        /// новый бар завершается сразу после превышения интервала бара
        /// </summary>
        /// <param name="tick"></param>
        public void OnItemAdded_v2(Tick tick)
        {
            /// обрабатываем поступление нового тика:
            /// валидация Symbol тика
            if (barSettings.Symbol != tick.Symbol) {
                if (tick.Symbol == "")
                {
                    tick.Symbol = barSettings.Symbol;
                }
                else
                {
                    return;
                }
            }

            /// внутренние состояния бара в процессе обработки тика
            //String state;
            while (true) {
                /// п2 если текущий бар отсутсвует
                if (barCurrent == null)
                {
                    //state = "Created";
                    ///     создаем новый текущий бар
                    ///         поступивший тик добавляем в текущий бар
                    ///         цена открытия = цене поступивщего тика
                    barCurrent = barBuilder.CreateBar(tick, tick.DateTime);
                    ///         переводим текущий бар в состоянии "обновлен"
                    ///         выходим из процесса обработки
                    break;
                }
                /// п0 если текущий бар в состоянии "закончен"
                if (barCurrent.State == Enums.BarState.Finished) {
                    //state = "Finished";
                    ///         создаем новый текущий бар
                    ///         цена открытия = цене закрытия предыдущего бара
                    barCurrent = barBuilder.CreateBar(barCurrent.Close, tick.DateTime, tick.Symbol);
                    //state = "Updated";
                    ///         переводим текущий бар в состоянии "обновлен"
                    ///         переходим в п1
                }
                /// п1 если текущий бар в состоянии "обновлен"
                if (barCurrent.State == Enums.BarState.Changed) {
                    //state = "Updated";
                    ///     проверяем возможность добавления нового тика в текущий бар
                    ///     если тело бара + расстояние до тика > значения интревала
                    ///     если добавить нельзя - интервал превышен
                    if (barBuilder.CheckRangeExcess(barCurrent, tick)) {
                        ///         цена закрытия = цене открытия + интервал
                        ///         переводим текущий бар в состояние "закончен"
                        barBuilder.UpdateBarFinish(barCurrent, tick);
                        //state = "Finished";
                        ///         добавить "законченый" бар в контекст
                        this.logger.Log(String.Format("{0:dd/MM/yyyy H:mm:ss.fff}, {1}, добавлен новый бар {2}", DateTime.Now, this.GetType().Name, barCurrent.ToString()));
                        this.tradingData.Get<ObservableCollection<Bar>>().Add(barCurrent);
                        ///         переходим в п0
                        continue;
                    }
                    ///     если добавить можно - интервал не превышен
                    ///     если значения интревала >= тело бара + расстояние до тика
                    else {
                        ///         поступивший тик добавляем в текущий бар
                        barCurrent = barBuilder.UpdateBar(barCurrent, tick);
                        //state = "Updated";
                        ///         сгенерировать событие бара "обновлен"
                        ///         выходим из процесса обработки
                        break;
                    }
                }
            }
        }
        /// <summary>
        /// обрабатываем поступление нового тика
        /// ц0
        /// п0 если текущий бар в состоянии "закончен"
        ///         создаем новый текущий бар
        ///         цена открытия = цене закрытия предыдущего бара
        ///         переводим текущий бар в состоянии "обновлен"
        ///         переходим в п1
        /// п1 если текущий бар в состоянии "обновлен"
        ///     проверяем возможность добавления нового тика в текущий бар
        ///     если тело бара + расстояние до тика > значения интревала
        ///     если добавить нельзя
        ///         переводим текущий бар в состояние "закончен"
        ///         цена закрытия = цене открытия + интервал
        ///             сгенерировать событие на "закончен" бара
        ///         добавить "законченый" бар в контекст
        ///         переходим в п0
        ///         continue;
        ///     если добавить можно        
        ///     если значения интревала >= тело бара + расстояние до тика
        ///         поступивший тик добавляем в текущий бар
        ///         сгенерировать событие бара "обновлен"
        ///         выходим из процесса обработки
        ///         break;
        /// п2 если текущий бар отсутсвует
        ///     создаем новый текущий бар
        ///         поступивший тик добавляем в текущий бар
        ///         цена открытия = цене поступивщего тика
        ///         переводим текущий бар в состоянии "обновлен"
        ///         выходим из процесса обработки
        ///         break;
        /// //новый бар завершается сразу после достижения интервала бара
        /// новый бар завершается сразу после превышения интервала бара
        /// </summary>
        /// <param name="tick"></param>
        public override void OnItemAdded(Tick tick)
        {
            /// обрабатываем поступление нового тика:
            /// валидация Symbol тика
            if (barSettings.Symbol != tick.Symbol)
            {
                if (tick.Symbol == "")
                {
                    tick.Symbol = barSettings.Symbol;
                }
                else
                {
                    return;
                }
            }

            /// внутренние состояния бара в процессе обработки тика
            //String state;
            while (true)
            {
                /// п2 если текущий бар отсутсвует
                if (barCurrent == null)
                {
                    //state = "Created";
                    ///     создаем новый текущий бар
                    ///         поступивший тик добавляем в текущий бар
                    ///         цена открытия = цене поступивщего тика
                    barCurrent = barBuilder.CreateBar(tick, tick.DateTime);
                    ///         переводим текущий бар в состоянии "обновлен"
                    ///         выходим из процесса обработки
                    break;
                }
                /// п0 если текущий бар в состоянии "закончен"
                if (barCurrent.State == Enums.BarState.Finished)
                {
                    //state = "Finished";
                    ///         создаем новый текущий бар
                    ///         цена открытия = цене закрытия предыдущего бара
                    barCurrent = barBuilder.CreateBar(barCurrent.Close, tick.DateTime, tick.Symbol);
                    //state = "Updated";
                    ///         переводим текущий бар в состоянии "обновлен"
                    ///         переходим в п1
                }
                /// п1 если текущий бар в состоянии "обновлен"
                if (barCurrent.State == Enums.BarState.Changed)
                {
                    //state = "Updated";
                    ///     проверяем возможность добавления нового тика в текущий бар
                    ///     если тело бара + расстояние до тика > значения интревала
                    ///     если добавить нельзя - интервал превышен
                    if (barBuilder.CheckRangeExcess(barCurrent, tick))
                    {
                        ///         цена закрытия = цене открытия + интервал
                        ///         переводим текущий бар в состояние "закончен"
                        barBuilder.UpdateBarFinish(barCurrent, tick);
                        //state = "Finished";
                        ///         добавить "законченый" бар в контекст
                        this.logger.Log(String.Format("{0:dd/MM/yyyy H:mm:ss.fff}, {1}, добавлен новый бар {2}", DateTime.Now, this.GetType().Name, barCurrent.ToString()));
                        this.tradingData.Get<ObservableCollection<Bar>>().Add(barCurrent);
                        ///         переходим в п0
                        continue;
                    }
                    ///     если добавить можно - интервал не превышен
                    ///     если значения интревала >= тело бара + расстояние до тика
                    else
                    {
                        ///         поступивший тик добавляем в текущий бар
                        barCurrent = barBuilder.UpdateBar(barCurrent, tick);
                        //state = "Updated";
                        ///         сгенерировать событие бара "обновлен"
                        ///         выходим из процесса обработки
                        //break;
                    }
                    ///     проверяем завершение бара новым тиком
                    if (barBuilder.CheckRangeReach(barCurrent))
                    {
                        ///         если текущий бар готов т.е. может быть закончен
                        ///             переводим текущий бар в состояние "закончен"
                        barBuilder.FinishBarState(barCurrent);
                        //state = "Finished";
                        ///             сгенерировать событие на "закончен" бара
                        ///             добавить завершенный бар в контекст                    
                        this.logger.Log(String.Format("{0:dd/MM/yyyy H:mm:ss.fff}, {1}, добавлен новый бар {2}", DateTime.Now, this.GetType().Name, barCurrent.ToString()));
                        this.tradingData.Get<ObservableCollection<Bar>>().Add(barCurrent);
                    }
                    ///         выходим из процесса обработки
                    break;
                }
            }
        }
    }
}
